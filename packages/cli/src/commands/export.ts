import { Command } from 'commander';
import { writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import chalk from 'chalk';
import { createV2Config, v2GetBrain } from '../lib/v2-api.js';

/* ═══════════════════════════════════════════════════════════════════════════════
 * contox export — Export V2 brain document for different AI tools
 *
 * Generates tool-specific context files from the project brain.
 *
 * Usage:
 *   contox export -f cursorrules       → .cursorrules
 *   contox export -f copilot           → .github/copilot-instructions.md
 *   contox export -f markdown          → contox-brain.md
 *   contox export -f markdown --stdout → print to stdout
 *   contox export -f copilot -o out.md → custom output path
 * ═══════════════════════════════════════════════════════════════════════════════ */

const VALID_FORMATS = ['cursorrules', 'copilot', 'markdown'] as const;
type ExportFormat = (typeof VALID_FORMATS)[number];

interface ExportOpts {
  format: string;
  output?: string;
  stdout?: boolean;
}

function isValidFormat(f: string): f is ExportFormat {
  return (VALID_FORMATS as readonly string[]).includes(f);
}

function formatDocument(format: ExportFormat, document: string, summary?: string): string {
  switch (format) {
    case 'cursorrules':
      // Cursor: conventions-focused, uses summary when available for conciseness
      return [
        '# Project Context (auto-generated by Contox)',
        '# Do not edit manually — run `contox export -f cursorrules` to update.',
        '',
        summary ?? document,
      ].join('\n');

    case 'copilot':
      // Copilot: structured, max 8000 chars, uses summary + essential document sections
      return [
        '# Project Instructions (auto-generated by Contox)',
        '<!-- Do not edit manually — run `contox export -f copilot` to update. -->',
        '',
        summary ?? document.slice(0, 8000),
      ].join('\n');

    case 'markdown':
      return document;
  }
}

function defaultOutputPath(format: ExportFormat): string {
  switch (format) {
    case 'cursorrules':
      return '.cursorrules';
    case 'copilot':
      return join('.github', 'copilot-instructions.md');
    case 'markdown':
      return 'contox-brain.md';
  }
}

export const exportCommand = new Command('export')
  .description('Export brain document for different AI tools')
  .requiredOption('-f, --format <format>', `Output format (${VALID_FORMATS.join(', ')})`)
  .option('-o, --output <path>', 'Output file path (defaults based on format)')
  .option('--stdout', 'Print to stdout instead of writing a file')
  .action(async (opts: ExportOpts) => {
    // Validate format
    if (!isValidFormat(opts.format)) {
      console.error(
        chalk.red('✗'),
        `Invalid format "${opts.format}". Must be one of: ${VALID_FORMATS.join(', ')}`,
      );
      process.exitCode = 1;
      return;
    }

    const format: ExportFormat = opts.format;

    // 1. Config check
    const config = createV2Config();
    if (!config) {
      console.error(chalk.red('✗'), 'Not configured. Run', chalk.cyan('contox login'), '&&', chalk.cyan('contox init'));
      process.exitCode = 1;
      return;
    }

    try {
      // 2. Fetch brain
      const brain = await v2GetBrain(config);

      if (!brain.document || brain.document.trim().length === 0) {
        console.error(chalk.yellow('⚠'), 'Brain document is empty. Nothing to export.');
        process.exitCode = 1;
        return;
      }

      // 3. Format (use summary for conventions-focused formats)
      const content = formatDocument(format, brain.document, brain.summary);

      // 4. Output
      if (opts.stdout) {
        process.stdout.write(content);
        return;
      }

      const outputPath = opts.output ?? defaultOutputPath(format);
      const resolvedPath = join(process.cwd(), outputPath);

      // Ensure parent directory exists for copilot format
      if (format === 'copilot' && !opts.output) {
        const { mkdir } = await import('node:fs/promises');
        await mkdir(join(process.cwd(), '.github'), { recursive: true });
      }

      await writeFile(resolvedPath, content, 'utf-8');

      console.log(
        chalk.green('✓'),
        `Exported ${chalk.cyan(format)} format to ${chalk.cyan(outputPath)}`,
        chalk.dim(`(${String(brain.itemsLoaded)} items, ~${String(brain.tokenEstimate)} tokens)`),
      );
    } catch (err) {
      console.error(chalk.red('✗'), 'Error:', (err as Error).message);
      process.exitCode = 1;
    }
  });
