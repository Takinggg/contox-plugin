import { basename } from 'node:path';
import type { ScanResult, RouteInfo, ComponentInfo, LibInfo } from './scanner.js';

/* ═══════════════════════════════════════════════════════════════════════════════
 * Context Builder — transforms a ScanResult into structured markdown documents
 * optimized for AI consumption. Each sub-context is a self-contained knowledge
 * unit that an AI can load to understand the project without reading source files.
 * ═══════════════════════════════════════════════════════════════════════════════ */

/**
 * Approximate token count (1 token ≈ 4 chars for English text).
 */
export function countTokens(text: string): number {
  return Math.ceil(text.length / 4);
}

/**
 * Build a single flat context document from scan results.
 */
export function buildContext(scan: ScanResult): string {
  const projectName = scan.packageJson
    ? String(scan.packageJson['name'] ?? basename(scan.root))
    : basename(scan.root);

  const sections: string[] = [];

  sections.push(`# Project Context: ${projectName}\n`);
  sections.push(`> Auto-generated by Contox CLI. Last updated: ${new Date().toISOString()}\n`);

  // Overview
  sections.push('## Overview\n');
  if (scan.packageJson?.['description']) {
    sections.push(`**Description**: ${String(scan.packageJson['description'])}\n`);
  }
  const stack = detectStack(scan);
  if (stack.length > 0) {
    sections.push(`**Stack**: ${stack.join(', ')}\n`);
  }
  sections.push(`**Files**: ${String(scan.stats.totalFiles)} files across ${String(scan.stats.totalDirs)} directories\n`);

  const sortedLangs = Object.entries(scan.stats.languages)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 8);
  if (sortedLangs.length > 0) {
    sections.push('**Languages**: ' + sortedLangs.map(([lang, count]) => `${lang} (${String(count)})`).join(', ') + '\n');
  }

  // Structure
  sections.push('## Project Structure\n');
  sections.push('```');
  sections.push(buildCompactTree(scan.tree));
  sections.push('```\n');

  // Routes
  if (scan.routes.length > 0) {
    sections.push(buildRoutesSection(scan.routes));
  }

  // Components
  if (scan.components.length > 0) {
    sections.push(buildComponentsSection(scan.components));
  }

  // Libraries
  if (scan.libs.length > 0) {
    sections.push(buildLibSection('Library Modules', scan.libs));
  }

  // Hooks
  if (scan.hooks.length > 0) {
    sections.push(buildLibSection('Hooks', scan.hooks));
  }

  // Stores
  if (scan.stores.length > 0) {
    sections.push(buildLibSection('State Stores', scan.stores));
  }

  // Dependencies
  if (scan.packageJson) {
    const depSection = buildDepsSection(scan.packageJson);
    if (depSection) sections.push(depSection);
  }

  // Config
  if (scan.tsConfig || scan.envExample) {
    sections.push(buildConfigSection(scan));
  }

  // Key files
  if (scan.keyFiles.length > 0) {
    sections.push(buildKeyFilesSection(scan.keyFiles));
  }

  return sections.join('\n');
}

/* ═══════════════════════════════════════════════════════════════════════════════
 * Sub-Context Builder — splits scan results into independent sub-contexts
 * for hierarchical storage. Each sub-context is a rich, self-contained document.
 * ═══════════════════════════════════════════════════════════════════════════════ */

export interface SubContextOutput {
  name: string;
  description: string;
  content: string;
  order: number;
  schemaKey: string;
  parentSchemaKey?: string;
  tier?: 1 | 2 | 3;
  contextType?: string;
}

/**
 * Build separate sub-contexts from scan results.
 * Each sub-context is a standalone markdown document with a brain schemaKey
 * for hierarchical storage via the populate API.
 *
 * Produces ~15 granular categories (vs the old 7) mapped to brain schemaKeys.
 */
export function buildSubContexts(scan: ScanResult): SubContextOutput[] {
  const projectName = scan.packageJson
    ? String(scan.packageJson['name'] ?? basename(scan.root))
    : basename(scan.root);

  const results: SubContextOutput[] = [];
  const timestamp = new Date().toISOString();
  const stack = detectStack(scan);

  const apiRoutes = scan.routes.filter(r => !r.methods.includes('PAGE'));
  const pageRoutes = scan.routes.filter(r => r.methods.includes('PAGE'));

  // ── 1. Overview ──────────────────────────────────────────────────────────
  {
    const lines: string[] = [];
    lines.push(`# ${projectName} — Project Overview\n`);
    lines.push(`> Scanned: ${timestamp}\n`);

    if (scan.packageJson?.['description']) {
      lines.push(`**Description**: ${String(scan.packageJson['description'])}\n`);
    }
    if (stack.length > 0) {
      lines.push(`**Stack**: ${stack.join(', ')}\n`);
    }
    lines.push(`**Stats**: ${String(scan.stats.totalFiles)} files, ${String(scan.stats.totalDirs)} directories`);
    lines.push(`**Routes**: ${String(apiRoutes.length)} API endpoints, ${String(pageRoutes.length)} pages`);
    lines.push(`**Components**: ${String(scan.components.length)} React components`);
    lines.push(`**Libraries**: ${String(scan.libs.length)} modules in src/lib/`);
    if (scan.hooks.length > 0) lines.push(`**Hooks**: ${String(scan.hooks.length)} custom hooks`);
    if (scan.stores.length > 0) lines.push(`**Stores**: ${String(scan.stores.length)} state stores`);
    lines.push('');

    const sortedLangs = Object.entries(scan.stats.languages)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 8);
    if (sortedLangs.length > 0) {
      lines.push('**Languages**: ' + sortedLangs.map(([lang, count]) => `${lang} (${String(count)})`).join(', ') + '\n');
    }

    lines.push('## Project Structure\n');
    lines.push('```');
    lines.push(buildCompactTree(scan.tree));
    lines.push('```\n');

    lines.push('## Architecture Notes\n');
    if (scan.routes.some(r => r.middleware.includes('withRateLimit'))) {
      lines.push('- API routes use `withRateLimit` middleware for rate limiting');
    }
    if (scan.routes.some(r => r.schemas.length > 0)) {
      lines.push('- Request validation via Zod schemas');
    }
    if (scan.middlewares.length > 0) {
      lines.push('- Next.js middleware active at `src/middleware.ts`');
    }
    if (scan.stores.length > 0) {
      lines.push(`- Client state management: ${String(scan.stores.length)} Zustand stores`);
    }
    if (scan.hooks.length > 0) {
      lines.push(`- ${String(scan.hooks.length)} custom React hooks in src/hooks/`);
    }
    lines.push('');

    results.push({
      name: '[Scan] Overview',
      description: `Project overview: ${stack.slice(0, 3).join(', ')}, ${String(scan.stats.totalFiles)} files`,
      content: lines.join('\n'),
      order: 0,
      schemaKey: 'root/scan',
      tier: 1,
      contextType: 'reference',
    });
  }

  // ── 2. Pages & Routes ──────────────────────────────────────────────────
  if (pageRoutes.length > 0) {
    const lines: string[] = [];
    lines.push('## Pages\n');
    lines.push('| Route | File |');
    lines.push('|-------|------|');
    for (const page of pageRoutes.sort((a, b) => a.path.localeCompare(b.path))) {
      lines.push(`| \`${page.path}\` | ${page.filePath} |`);
    }
    lines.push('');

    results.push({
      name: '[Scan] Pages & Routes',
      description: `${String(pageRoutes.length)} Next.js page routes`,
      content: lines.join('\n'),
      order: 1,
      schemaKey: 'root/frontend/pages',
      parentSchemaKey: 'root/frontend',
      tier: 2,
      contextType: 'reference',
    });
  }

  // ── 3–6. API Endpoints — split by domain ──────────────────────────────
  if (apiRoutes.length > 0) {
    const authRoutes = apiRoutes.filter(r =>
      /^\/api\/(auth|user|team|orgs)/.test(r.path));
    const coreRoutes = apiRoutes.filter(r =>
      /^\/api\/(contexts|projects|context-entries|context-links)/.test(r.path));
    const integrationRoutes = apiRoutes.filter(r =>
      /^\/api\/(billing|integrations|webhooks|keys|ai)/.test(r.path));
    const categorized = new Set([...authRoutes, ...coreRoutes, ...integrationRoutes]);
    const systemRoutes = apiRoutes.filter(r => !categorized.has(r));

    // Parent node — always create root/api so children can be parented
    const apiSummary = systemRoutes.length > 0
      ? buildRouteSectionForGroup('API: System & Admin', systemRoutes)
      : `## API Overview\n\n${String(apiRoutes.length)} API endpoints across ${String(authRoutes.length > 0 ? 1 : 0) + String(coreRoutes.length > 0 ? 1 : 0) + String(integrationRoutes.length > 0 ? 1 : 0)} domains.`;

    results.push({
      name: '[Scan] API: System',
      description: `${String(apiRoutes.length)} total API endpoints (${String(systemRoutes.length)} system)`,
      content: apiSummary,
      order: 2,
      schemaKey: 'root/api',
      tier: 2,
      contextType: 'reference',
    });

    if (authRoutes.length > 0) {
      results.push({
        name: '[Scan] API: Auth & User',
        description: `${String(authRoutes.length)} endpoints: auth, user, team, orgs`,
        content: buildRouteSectionForGroup('API: Auth & User Management', authRoutes),
        order: 3,
        schemaKey: 'root/api/auth',
        parentSchemaKey: 'root/api',
        tier: 2,
        contextType: 'reference',
      });
    }

    if (coreRoutes.length > 0) {
      results.push({
        name: '[Scan] API: Core CRUD',
        description: `${String(coreRoutes.length)} endpoints: contexts, projects, entries, links`,
        content: buildRouteSectionForGroup('API: Core CRUD', coreRoutes),
        order: 4,
        schemaKey: 'root/api/core',
        parentSchemaKey: 'root/api',
        tier: 2,
        contextType: 'reference',
      });
    }

    if (integrationRoutes.length > 0) {
      results.push({
        name: '[Scan] API: Integrations',
        description: `${String(integrationRoutes.length)} endpoints: billing, integrations, webhooks, keys, AI`,
        content: buildRouteSectionForGroup('API: Integrations', integrationRoutes),
        order: 5,
        schemaKey: 'root/api/integrations',
        parentSchemaKey: 'root/api',
        tier: 2,
        contextType: 'reference',
      });
    }
  }

  // ── 7–9. Components — split by directory ──────────────────────────────
  if (scan.components.length > 0) {
    const domainComps = scan.components.filter(c => c.filePath.includes('/contox/'));
    const uiComps = scan.components.filter(c => c.filePath.includes('/ui/'));
    const pageComps = scan.components.filter(c =>
      c.filePath.includes('/pages/') || c.filePath.includes('/landing/') || c.filePath.includes('/providers/') || c.filePath.includes('/skeletons/') || c.filePath.includes('/icons/'));
    const categorized = new Set([...domainComps, ...uiComps, ...pageComps]);
    const otherComps = scan.components.filter(c => !categorized.has(c));

    if (domainComps.length > 0) {
      results.push({
        name: '[Scan] Components: Domain',
        description: `${String(domainComps.length)} domain components (brain, editor, entries, etc.)`,
        content: buildComponentsSection(domainComps),
        order: 6,
        schemaKey: 'root/frontend',
        tier: 2,
        contextType: 'reference',
      });
    }

    if (uiComps.length > 0) {
      results.push({
        name: '[Scan] Components: UI Library',
        description: `${String(uiComps.length)} UI primitives (buttons, cards, dialogs, etc.)`,
        content: buildComponentsSection(uiComps),
        order: 7,
        schemaKey: 'root/frontend/ui',
        parentSchemaKey: 'root/frontend',
        tier: 3,
        contextType: 'reference',
      });
    }

    if (pageComps.length > 0) {
      const combined = [...pageComps, ...otherComps];
      results.push({
        name: '[Scan] Components: Pages & Layout',
        description: `${String(combined.length)} page, landing, provider, and layout components`,
        content: buildComponentsSection(combined),
        order: 8,
        schemaKey: 'root/frontend/layout',
        parentSchemaKey: 'root/frontend',
        tier: 2,
        contextType: 'reference',
      });
    } else if (otherComps.length > 0) {
      results.push({
        name: '[Scan] Components: Other',
        description: `${String(otherComps.length)} uncategorized components`,
        content: buildComponentsSection(otherComps),
        order: 8,
        schemaKey: 'root/frontend/layout',
        parentSchemaKey: 'root/frontend',
        tier: 2,
        contextType: 'reference',
      });
    }
  }

  // ── 10. Hooks ─────────────────────────────────────────────────────────
  if (scan.hooks.length > 0) {
    results.push({
      name: '[Scan] Hooks',
      description: `${String(scan.hooks.length)} custom React hooks`,
      content: buildLibSection('Custom Hooks (src/hooks/)', scan.hooks),
      order: 9,
      schemaKey: 'root/frontend/hooks',
      parentSchemaKey: 'root/frontend',
      tier: 2,
      contextType: 'reference',
    });
  }

  // ── 11. State Stores ──────────────────────────────────────────────────
  if (scan.stores.length > 0) {
    results.push({
      name: '[Scan] State Stores',
      description: `${String(scan.stores.length)} Zustand stores`,
      content: buildLibSection('State Stores (src/stores/)', scan.stores),
      order: 10,
      schemaKey: 'root/frontend/stores',
      parentSchemaKey: 'root/frontend',
      tier: 2,
      contextType: 'reference',
    });
  }

  // ── 12–15. Libraries — split by purpose ───────────────────────────────
  if (scan.libs.length > 0 || scan.middlewares.length > 0) {
    const middlewareLibs = scan.libs.filter(l =>
      l.filePath.includes('/middleware/'));
    const serviceLibs = scan.libs.filter(l =>
      /\/(stripe|email|openrouter|rate-limiter|quotas|webhook-dispatcher|activity-logger)/.test(l.filePath));
    const validationLibs = scan.libs.filter(l =>
      l.filePath.includes('/validations/'));
    const categorized = new Set([...middlewareLibs, ...serviceLibs, ...validationLibs]);
    const coreLibs = scan.libs.filter(l => !categorized.has(l));

    // Parent node — always create root/backend so children can be parented
    const totalModules = scan.libs.length + scan.middlewares.length;
    const totalExports = [...scan.libs, ...scan.middlewares]
      .reduce((sum, l) => sum + l.exports.length, 0);

    // Build rich content for the parent node
    const backendLines: string[] = [];
    backendLines.push('## Backend Overview\n');
    backendLines.push(`**${String(totalModules)} modules** — ${String(totalExports)} exported functions/types\n`);
    backendLines.push('| Category | Count | Key Modules |');
    backendLines.push('|----------|-------|-------------|');
    if (coreLibs.length > 0) {
      const topCore = coreLibs.slice(0, 5).map(l => `\`${basename(l.filePath).replace(/\.(ts|js)$/, '')}\``).join(', ');
      backendLines.push(`| Core | ${String(coreLibs.length)} | ${topCore} |`);
    }
    if (serviceLibs.length > 0) {
      const topSvc = serviceLibs.map(l => `\`${basename(l.filePath).replace(/\.(ts|js)$/, '')}\``).join(', ');
      backendLines.push(`| Services | ${String(serviceLibs.length)} | ${topSvc} |`);
    }
    if (validationLibs.length > 0) {
      backendLines.push(`| Validations | ${String(validationLibs.length)} | Zod schemas for API input |`);
    }
    if (middlewareLibs.length > 0 || scan.middlewares.length > 0) {
      const mwCount = middlewareLibs.length + scan.middlewares.length;
      backendLines.push(`| Middleware | ${String(mwCount)} | auth-derive, brain-invariants |`);
    }
    backendLines.push('');

    results.push({
      name: '[Scan] Backend Overview',
      description: `${String(totalModules)} backend modules, ${String(totalExports)} exports`,
      content: backendLines.join('\n'),
      order: 11,
      schemaKey: 'root/backend',
      tier: 2,
      contextType: 'reference',
    });

    if (coreLibs.length > 0) {
      results.push({
        name: '[Scan] Libs: Core',
        description: `${String(coreLibs.length)} core libraries (appwrite, auth, utils, etc.)`,
        content: buildLibSection('Core Libraries', coreLibs),
        order: 12,
        schemaKey: 'root/backend/logic',
        parentSchemaKey: 'root/backend',
        tier: 2,
        contextType: 'reference',
      });
    }

    if (serviceLibs.length > 0) {
      results.push({
        name: '[Scan] Libs: Services',
        description: `${String(serviceLibs.length)} service integrations (stripe, email, AI, etc.)`,
        content: buildLibSection('Service Integrations', serviceLibs),
        order: 13,
        schemaKey: 'root/backend/integrations',
        parentSchemaKey: 'root/backend',
        tier: 2,
        contextType: 'reference',
      });
    }

    if (validationLibs.length > 0) {
      results.push({
        name: '[Scan] Libs: Validations',
        description: `${String(validationLibs.length)} Zod validation schemas`,
        content: buildLibSection('Validation Schemas', validationLibs),
        order: 14,
        schemaKey: 'root/backend/validations',
        parentSchemaKey: 'root/backend',
        tier: 2,
        contextType: 'reference',
      });
    }

    if (middlewareLibs.length > 0 || scan.middlewares.length > 0) {
      const allMiddleware = [...middlewareLibs, ...scan.middlewares];
      results.push({
        name: '[Scan] Auth & Middleware',
        description: `${String(allMiddleware.length)} auth/middleware modules`,
        content: buildLibSection('Auth & Middleware', allMiddleware),
        order: 15,
        schemaKey: 'root/backend/auth',
        parentSchemaKey: 'root/backend',
        tier: 2,
        contextType: 'reference',
      });
    }
  }

  // ── 16. Dependencies ──────────────────────────────────────────────────
  if (scan.packageJson) {
    const depSection = buildDepsSection(scan.packageJson);
    if (depSection) {
      const deps = scan.packageJson['dependencies'] as Record<string, string> | undefined;
      results.push({
        name: '[Scan] Dependencies',
        description: `${String(Object.keys(deps ?? {}).length)} runtime deps, npm scripts`,
        content: depSection,
        order: 16,
        schemaKey: 'root/stack',
        tier: 2,
        contextType: 'reference',
      });
    }
  }

  // ── 17. Configuration ─────────────────────────────────────────────────
  if (scan.tsConfig || scan.envExample) {
    results.push({
      name: '[Scan] Configuration',
      description: 'TypeScript config, environment variables',
      content: buildConfigSection(scan),
      order: 17,
      schemaKey: 'root/stack/environment',
      parentSchemaKey: 'root/stack',
      tier: 2,
      contextType: 'reference',
    });
  }

  // ── 18. Packages ──────────────────────────────────────────────────────
  if (scan.keyFiles.some(f => f.path.startsWith('packages/'))) {
    const pkgFiles = scan.keyFiles.filter(f => f.path.startsWith('packages/'));
    results.push({
      name: '[Scan] Packages',
      description: `${String(pkgFiles.length)} monorepo packages (CLI, MCP, plugins)`,
      content: buildKeyFilesSection(pkgFiles),
      order: 18,
      schemaKey: 'root/packages',
      tier: 2,
      contextType: 'reference',
    });
  }

  // ── 19. Documentation ─────────────────────────────────────────────────
  {
    const nonPkgDocs = scan.keyFiles.filter(f => !f.path.startsWith('packages/'));
    if (nonPkgDocs.length > 0) {
      results.push({
        name: '[Scan] Documentation',
        description: `Key docs: ${nonPkgDocs.map((f) => f.path).join(', ')}`,
        content: buildKeyFilesSection(nonPkgDocs),
        order: 19,
        schemaKey: 'root/scan/docs',
        parentSchemaKey: 'root/scan',
        tier: 3,
        contextType: 'reference',
      });
    }
  }

  return results;
}

/* ═══════════════════════════════════════════════════════════════════════════════
 * Section Builders — create rich markdown sections for each domain
 * ═══════════════════════════════════════════════════════════════════════════════ */

function buildRouteSectionForGroup(title: string, routes: RouteInfo[]): string {
  const lines: string[] = [];
  lines.push(`## ${title}\n`);

  for (const route of routes.sort((a, b) => a.path.localeCompare(b.path))) {
    const methods = route.methods.length > 0 ? route.methods.join(', ') : 'UNKNOWN';
    lines.push(`### \`${methods}\` ${route.path}`);
    lines.push(`> File: \`${route.filePath}\``);

    if (route.middleware.length > 0) {
      lines.push(`> Middleware: ${route.middleware.map(m => `\`${m}\``).join(', ')}`);
    }

    if (route.schemas.length > 0) {
      lines.push('\n**Request schemas:**');
      lines.push('```typescript');
      for (const schema of route.schemas) {
        lines.push(schema);
      }
      lines.push('```');
    }
    lines.push('');
  }

  return lines.join('\n');
}

function buildRoutesSection(routes: RouteInfo[]): string {
  const lines: string[] = [];
  const pages = routes.filter(r => r.methods.includes('PAGE')).sort((a, b) => a.path.localeCompare(b.path));
  const apiRoutes = routes.filter(r => !r.methods.includes('PAGE')).sort((a, b) => a.path.localeCompare(b.path));

  if (pages.length > 0) {
    lines.push('## Pages\n');
    lines.push('| Route | File |');
    lines.push('|-------|------|');
    for (const page of pages) {
      lines.push(`| \`${page.path}\` | ${page.filePath} |`);
    }
    lines.push('');
  }

  if (apiRoutes.length > 0) {
    lines.push('## API Endpoints\n');
    for (const route of apiRoutes) {
      const methods = route.methods.length > 0 ? route.methods.join(', ') : 'UNKNOWN';
      lines.push(`### \`${methods}\` ${route.path}`);
      lines.push(`> File: \`${route.filePath}\``);

      if (route.middleware.length > 0) {
        lines.push(`> Middleware: ${route.middleware.map(m => `\`${m}\``).join(', ')}`);
      }

      if (route.schemas.length > 0) {
        lines.push('\n**Request schemas:**');
        lines.push('```typescript');
        for (const schema of route.schemas) {
          lines.push(schema);
        }
        lines.push('```');
      }
      lines.push('');
    }
  }

  return lines.join('\n');
}

function buildComponentsSection(components: ComponentInfo[]): string {
  const lines: string[] = [];
  lines.push('## Components\n');

  // Group by directory
  const groups = groupByDir(components.map(c => c.filePath));
  const componentMap = new Map(components.map(c => [c.filePath, c]));

  for (const [dir, files] of groups) {
    lines.push(`### ${dir}\n`);

    for (const filePath of files) {
      const comp = componentMap.get(filePath);
      if (!comp) continue;

      const desc = comp.description ? ` — ${comp.description}` : '';
      lines.push(`#### \`${comp.name}\`${desc}`);
      lines.push(`> File: \`${comp.filePath}\``);

      if (comp.props) {
        lines.push('\n**Props:**');
        lines.push('```typescript');
        lines.push(comp.props);
        lines.push('```');
      }
      lines.push('');
    }
  }

  return lines.join('\n');
}

function buildLibSection(title: string, libs: LibInfo[]): string {
  const lines: string[] = [];
  lines.push(`## ${title}\n`);

  for (const lib of libs.sort((a, b) => a.filePath.localeCompare(b.filePath))) {
    const moduleName = basename(lib.filePath).replace(/\.(ts|js)$/, '');
    const desc = lib.description ? ` — ${lib.description}` : '';
    lines.push(`### \`${moduleName}\`${desc}`);
    lines.push(`> File: \`${lib.filePath}\``);

    if (lib.exports.length > 0) {
      lines.push('');
      lines.push('```typescript');
      for (const exp of lib.exports) {
        lines.push(`export ${exp.signature}`);
      }
      lines.push('```');
    } else {
      lines.push('\n*No public exports detected*');
    }
    lines.push('');
  }

  return lines.join('\n');
}

function buildDepsSection(packageJson: Record<string, unknown>): string | null {
  const lines: string[] = [];
  const deps = packageJson['dependencies'] as Record<string, string> | undefined;
  const devDeps = packageJson['devDependencies'] as Record<string, string> | undefined;

  if (deps && Object.keys(deps).length > 0) {
    lines.push('## Runtime Dependencies\n');
    const categories = categorizeDeps(deps);
    for (const [cat, items] of categories) {
      lines.push(`**${cat}**: ${items.map(([n, v]) => `${n} ${v}`).join(', ')}`);
    }
    lines.push('');
  }

  if (devDeps && Object.keys(devDeps).length > 0) {
    lines.push('## Dev Dependencies\n');
    const categories = categorizeDeps(devDeps);
    for (const [cat, items] of categories) {
      lines.push(`**${cat}**: ${items.map(([n, v]) => `${n} ${v}`).join(', ')}`);
    }
    lines.push('');
  }

  const scripts = packageJson['scripts'] as Record<string, string> | undefined;
  if (scripts && Object.keys(scripts).length > 0) {
    lines.push('## NPM Scripts\n');
    lines.push('```');
    for (const [name, cmd] of Object.entries(scripts)) {
      lines.push(`${name}: ${cmd}`);
    }
    lines.push('```');
  }

  return lines.length > 0 ? lines.join('\n') : null;
}

function buildConfigSection(scan: ScanResult): string {
  const lines: string[] = [];

  if (scan.tsConfig) {
    const compilerOpts = scan.tsConfig['compilerOptions'] as Record<string, unknown> | undefined;
    if (compilerOpts) {
      lines.push('## TypeScript Configuration\n');
      lines.push('```json');
      lines.push(JSON.stringify({ compilerOptions: compilerOpts }, null, 2));
      lines.push('```\n');
    }
  }

  if (scan.envExample) {
    lines.push('## Environment Variables\n');
    lines.push('```env');
    lines.push(scan.envExample.trim());
    lines.push('```');
  }

  return lines.join('\n');
}

function buildKeyFilesSection(keyFiles: Array<{ path: string; content: string; reason: string }>): string {
  const lines: string[] = [];
  lines.push('## Key Documentation\n');

  for (const kf of keyFiles) {
    lines.push(`### ${kf.path}`);
    lines.push(`> ${kf.reason}\n`);
    const ext = kf.path.split('.').pop() ?? '';
    const lang = ext === 'md' ? 'markdown' : ext;
    lines.push(`\`\`\`${lang}`);
    const maxLen = 8000;
    if (kf.content.length > maxLen) {
      lines.push(kf.content.slice(0, maxLen));
      lines.push(`\n... [truncated, ${String(Math.round(kf.content.length / 1024))}KB total]`);
    } else {
      lines.push(kf.content);
    }
    lines.push('```\n');
  }

  return lines.join('\n');
}

/* ═══════════════════════════════════════════════════════════════════════════════
 * Helpers
 * ═══════════════════════════════════════════════════════════════════════════════ */

function detectStack(scan: ScanResult): string[] {
  const stack: string[] = [];
  if (!scan.packageJson) return stack;

  const allDeps = {
    ...(scan.packageJson['dependencies'] as Record<string, string> | undefined ?? {}),
    ...(scan.packageJson['devDependencies'] as Record<string, string> | undefined ?? {}),
  };

  if (allDeps['next']) stack.push(`Next.js ${allDeps['next']}`);
  else if (allDeps['nuxt']) stack.push(`Nuxt ${allDeps['nuxt']}`);
  else if (allDeps['@angular/core']) stack.push(`Angular ${allDeps['@angular/core']}`);
  else if (allDeps['svelte']) stack.push(`Svelte ${allDeps['svelte']}`);
  else if (allDeps['astro']) stack.push(`Astro ${allDeps['astro']}`);
  else if (allDeps['react']) stack.push(`React ${allDeps['react']}`);
  else if (allDeps['vue']) stack.push(`Vue ${allDeps['vue']}`);

  if (allDeps['typescript']) stack.push('TypeScript');
  if (allDeps['tailwindcss']) stack.push('Tailwind CSS');
  else if (allDeps['styled-components']) stack.push('styled-components');

  if (allDeps['prisma'] || allDeps['@prisma/client']) stack.push('Prisma');
  else if (allDeps['drizzle-orm']) stack.push('Drizzle');
  else if (allDeps['mongoose']) stack.push('MongoDB');
  else if (allDeps['pg']) stack.push('PostgreSQL');

  if (allDeps['appwrite'] || allDeps['node-appwrite']) stack.push('Appwrite');
  else if (allDeps['firebase'] || allDeps['firebase-admin']) stack.push('Firebase');
  else if (allDeps['@supabase/supabase-js']) stack.push('Supabase');

  if (allDeps['next-auth']) stack.push('NextAuth');
  else if (allDeps['@clerk/nextjs']) stack.push('Clerk');

  if (allDeps['zustand']) stack.push('Zustand');
  else if (allDeps['@reduxjs/toolkit']) stack.push('Redux');
  else if (allDeps['jotai']) stack.push('Jotai');

  if (allDeps['vitest']) stack.push('Vitest');
  else if (allDeps['jest']) stack.push('Jest');

  if (allDeps['stripe']) stack.push('Stripe');
  if (allDeps['resend']) stack.push('Resend');
  if (allDeps['@sentry/nextjs']) stack.push('Sentry');

  return stack;
}

function buildCompactTree(tree: string[]): string {
  const lines: string[] = [];
  const dirContents = new Map<string, { dirs: string[]; fileCount: number }>();

  dirContents.set('', { dirs: [], fileCount: 0 });

  for (const entry of tree) {
    const isDir = entry.endsWith('/');
    const parts = entry.replace(/\/$/, '').split('/');

    if (isDir && parts.length <= 3) {
      const parentDir = parts.slice(0, -1).join('/');
      const dirName = parts[parts.length - 1] ?? '';

      if (!dirContents.has(parentDir)) {
        dirContents.set(parentDir, { dirs: [], fileCount: 0 });
      }
      dirContents.get(parentDir)!.dirs.push(dirName);

      if (!dirContents.has(entry.replace(/\/$/, ''))) {
        dirContents.set(entry.replace(/\/$/, ''), { dirs: [], fileCount: 0 });
      }
    } else if (!isDir) {
      const parentDir = parts.slice(0, -1).join('/');
      let tracked = parentDir;
      while (tracked && !dirContents.has(tracked)) {
        tracked = tracked.split('/').slice(0, -1).join('/');
      }
      if (dirContents.has(tracked)) {
        dirContents.get(tracked)!.fileCount++;
      }
    }
  }

  function printDir(dir: string, depth: number): void {
    const info = dirContents.get(dir);
    if (!info) return;

    for (const subDir of info.dirs.sort()) {
      const fullDir = dir ? `${dir}/${subDir}` : subDir;
      const subInfo = dirContents.get(fullDir);
      const indent = '  '.repeat(depth);
      const fileNote = subInfo?.fileCount ? ` (${String(subInfo.fileCount)} files)` : '';
      lines.push(`${indent}${subDir}/${fileNote}`);
      printDir(fullDir, depth + 1);
    }
  }

  const rootInfo = dirContents.get('');
  if (rootInfo?.fileCount) {
    lines.push(`(${String(rootInfo.fileCount)} root files)`);
  }
  printDir('', 0);

  return lines.join('\n');
}

function groupByDir(paths: string[]): Array<[string, string[]]> {
  const groups = new Map<string, string[]>();
  for (const p of paths) {
    const parts = p.split('/');
    const key = parts.slice(0, 3).join('/');
    if (!groups.has(key)) {
      groups.set(key, []);
    }
    groups.get(key)!.push(p);
  }
  return [...groups.entries()].sort(([a], [b]) => a.localeCompare(b));
}

/**
 * Categorize dependencies by their purpose for better readability.
 */
function categorizeDeps(deps: Record<string, string>): Array<[string, Array<[string, string]>]> {
  const categories = new Map<string, Array<[string, string]>>();

  for (const [name, version] of Object.entries(deps)) {
    let cat = 'Other';

    if (name.match(/^(next|react|react-dom|vue|nuxt|svelte|astro|@angular)/)) cat = 'Framework';
    else if (name.match(/^(@dnd-kit|framer-motion|@radix|@headlessui|lucide|@heroicons)/)) cat = 'UI';
    else if (name.match(/^(tailwindcss|postcss|autoprefixer|sass|styled-)/)) cat = 'Styling';
    else if (name.match(/^(prisma|drizzle|mongoose|pg|@prisma|typeorm)/)) cat = 'Database';
    else if (name.match(/^(appwrite|node-appwrite|firebase|@supabase)/)) cat = 'Backend/BaaS';
    else if (name.match(/^(next-auth|@clerk|passport|bcrypt|jsonwebtoken)/)) cat = 'Auth';
    else if (name.match(/^(zustand|@reduxjs|jotai|recoil|mobx)/)) cat = 'State';
    else if (name.match(/^(vitest|jest|@testing|playwright|cypress|@playwright)/)) cat = 'Testing';
    else if (name.match(/^(typescript|@types\/|eslint|prettier|@eslint)/)) cat = 'Tooling';
    else if (name.match(/^(stripe|@stripe)/)) cat = 'Payments';
    else if (name.match(/^(resend|nodemailer|@sendgrid)/)) cat = 'Email';
    else if (name.match(/^(@sentry|sentry)/)) cat = 'Monitoring';
    else if (name.match(/^(zod|yup|joi|class-validator)/)) cat = 'Validation';
    else if (name.match(/^(next-intl|i18next|react-intl)/)) cat = 'i18n';
    else if (name.match(/^(@storybook|storybook|chromatic)/)) cat = 'Storybook';

    if (!categories.has(cat)) categories.set(cat, []);
    categories.get(cat)!.push([name, version]);
  }

  const order = ['Framework', 'Backend/BaaS', 'Auth', 'Database', 'State', 'UI', 'Styling', 'Validation', 'Payments', 'Email', 'i18n', 'Monitoring', 'Testing', 'Storybook', 'Tooling', 'Other'];
  return [...categories.entries()].sort(([a], [b]) => {
    const ai = order.indexOf(a);
    const bi = order.indexOf(b);
    return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);
  });
}
